/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2014 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
// char *getenv(const char *name);
// int puts(const char *s);
// size_t strlen(const char *s);
// int __fastcall __gmpz_get_str(_QWORD, _QWORD, _QWORD); weak
// int __fastcall __gmpz_mul_ui(_QWORD, _QWORD, _QWORD); weak
// int strcmp(const char *s1, const char *s2);
// int __fastcall __gmpz_add_ui(_QWORD, _QWORD, _QWORD); weak
// int __gmon_start__(void); weak
// int prctl(int option, ...);
// int __fastcall __gmpz_clear(_QWORD); weak
// __int64 ptrace(enum __ptrace_request request, ...);
// __pid_t getppid(void);
// void __noreturn exit(int status);
// int __fastcall __gmpz_init(_QWORD); weak
// unsigned int sleep(unsigned int seconds);
// __pid_t wait(__WAIT_STATUS stat_loc);
// __pid_t fork(void);
int sub_400AA0();
int sub_400AD0();
int sub_400B10();
int sub_400B30();
size_t __fastcall sub_400B5D(const char *a1, const char *a2);
__int64 __fastcall sub_400C02(__int64 a1);
__int64 __fastcall sub_400C46(int a1, __int64 a2);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

char *s2 = "From a seed a mighty trunk may grow.\n"; // idb
char *off_6020C8 = "01111101001000101000000111101001001011111110010011100111010011000010101101110110100001101011100101001110000000001101000110001011011010101001000000010010001100011001100011001011010101111011110110001100101100101000110011101111101101000110110010101001100100110100010101101111101111011001100011111101"; // weak
char _bss_start; // weak
// extern _UNKNOWN _gmon_start__; weak


//----- (0000000000400908) ----------------------------------------------------
int init_proc()
{
  _UNKNOWN *v0; // rax@1

  v0 = &_gmon_start__;
  if ( &_gmon_start__ )
    LODWORD(v0) = __gmon_start__();
  return (signed int)v0;
}
// 4009D0: using guessed type int __gmon_start__(void);

//----- (0000000000400A70) ----------------------------------------------------
#error "400A76: positive sp value has been found (funcsize=3)"

//----- (0000000000400AA0) ----------------------------------------------------
int sub_400AA0()
{
  signed __int64 v0; // rax@1

  v0 = 6299863LL - (_QWORD)&_bss_start;
  if ( (unsigned __int64)(6299863LL - (_QWORD)&_bss_start) > 0xE )
    LODWORD(v0) = 0;
  return v0;
}
// 6020D0: using guessed type char _bss_start;

//----- (0000000000400AD0) ----------------------------------------------------
int sub_400AD0()
{
  return (signed __int64)(((unsigned __int64)(6299856LL - (_QWORD)&_bss_start) >> 63)
                        + ((6299856 - (signed __int64)&_bss_start) >> 3)) >> 1;
}
// 6020D0: using guessed type char _bss_start;

//----- (0000000000400B10) ----------------------------------------------------
int sub_400B10()
{
  int result; // eax@2

  if ( !_bss_start )
  {
    result = sub_400AA0();
    _bss_start = 1;
  }
  return result;
}
// 6020D0: using guessed type char _bss_start;

//----- (0000000000400B30) ----------------------------------------------------
int sub_400B30()
{
  return sub_400AD0();
}
// 400B30: could not find valid save-restore pair for rbp

//----- (0000000000400B5D) ----------------------------------------------------
size_t __fastcall sub_400B5D(const char *a1, const char *a2)
{
  size_t v2; // rbx@1
  char v3; // al@5
  size_t result; // rax@8
  int i; // [sp+1Ch] [bp-14h]@3

  v2 = strlen(a1);
  if ( v2 != strlen(a2) )
    exit(0);
  for ( i = 0; ; ++i )
  {
    result = strlen(a1);
    if ( i >= result )
      break;
    if ( a1[i] == a2[i] )
      v3 = 49;
    else
      v3 = 48;
    a1[i] = v3;
  }
  return result;
}

//----- (0000000000400C02) ----------------------------------------------------
__int64 __fastcall sub_400C02(__int64 a1)
{
  unsigned __int8 v2; // [sp+13h] [bp-5h]@1
  signed int i; // [sp+14h] [bp-4h]@1

  v2 = 0;
  for ( i = 0; i <= 7; ++i )
    v2 = *(_BYTE *)(i + a1) + 2 * v2 - 48;
  return v2;
}

//----- (0000000000400C46) ----------------------------------------------------
__int64 __fastcall sub_400C46(int argc, __int64 a2)
{
  int v2; // eax@7
  size_t v3; // rbx@15
  char *v4; // rax@16
  char v5; // al@17
  size_t v6; // rbx@18
  __int64 v8; // [sp+0h] [bp-90h]@4
  __WAIT_STATUS stat_loc; // [sp+18h] [bp-78h]@10
  int i; // [sp+20h] [bp-70h]@16
  int v11; // [sp+24h] [bp-6Ch]@4
  int v12; // [sp+28h] [bp-68h]@5
  int v13; // [sp+2Ch] [bp-64h]@5
  char *s; // [sp+30h] [bp-60h]@12
  char *v15; // [sp+38h] [bp-58h]@16
  char v16; // [sp+40h] [bp-50h]@13
  char s1[40]; // [sp+50h] [bp-40h]@17
  __int64 v18; // [sp+78h] [bp-18h]@1

  v18 = *MK_FP(__FS__, 40LL);
  if ( argc != 2 )
  {
    puts("You should give me the flag as command-line parameter!");
    exit(0);
  }
  prctl(1499557217, -1LL, 0LL, 0LL, 0LL, a2);
  v11 = fork();
  if ( !v11 )
  {
    v12 = getppid();
    v13 = ptrace(PTRACE_ATTACH, (unsigned int)v12, 0LL, 0LL);
    sleep(1u);
    ptrace(PTRACE_DETACH, (unsigned int)v12, 0LL, 0LL);
    v2 = v13 || getenv("LD_PRELOAD");
    exit(v2);
  }
  wait((__WAIT_STATUS)&stat_loc);
  if ( (_DWORD)stat_loc.__uptr )
    exit(0);
  s = *(char **)(v8 + 8);
  if ( strlen(s) == 36 )
  {
    __gmpz_init(&v16);
    for ( HIDWORD(stat_loc.__iptr) = 0; ; ++HIDWORD(stat_loc.__iptr) )
    {
      v3 = SHIDWORD(stat_loc.__iptr);
      if ( v3 >= strlen(s) )
        break;
      __gmpz_mul_ui(&v16, &v16, 307LL);
      __gmpz_add_ui(&v16, &v16, s[SHIDWORD(stat_loc.__iptr)]);
    }
    LODWORD(v4) = __gmpz_get_str(0LL, 2LL, &v16);
    v15 = v4;
    __gmpz_clear(&v16);
    sub_400B5D(v15, off_6020C8);
    for ( i = 0; ; ++i )
    {
      v6 = i;
      if ( v6 >= strlen(v15) >> 3 )
        break;
      v5 = sub_400C02((__int64)&v15[8 * i]);
      s1[i] = v5;                                                           // on rempli s1 caractère par caractère
    }
    if ( !strcmp(s1, s2) )
      puts("Success! You've found the right flag!");
  }
  return *MK_FP(__FS__, 40LL) ^ v18;
}
// 400970: using guessed type int __fastcall __gmpz_get_str(_QWORD, _QWORD, _QWORD);
// 400990: using guessed type int __fastcall __gmpz_mul_ui(_QWORD, _QWORD, _QWORD);
// 4009C0: using guessed type int __fastcall __gmpz_add_ui(_QWORD, _QWORD, _QWORD);
// 4009F0: using guessed type int __fastcall __gmpz_clear(_QWORD);
// 400A30: using guessed type int __fastcall __gmpz_init(_QWORD);
// 6020C8: using guessed type char *off_6020C8;
// 400C46: using guessed type char s1[40];

//----- (0000000000400F34) ----------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 1 decompilation failure(s) on 10 function(s)"
